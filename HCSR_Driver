//#include <stdlib.h>
#include <linux/miscdevice.h>
#include <linux/fs.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/list.h>
#include <linux/slab.h>

static int devices = 1;

module_param(devices, int, 0644);
MODULE_PARM_DESC(devices, "The number of HCSR devices to be created.");

struct hcsr04_device {
	struct miscdevice misc;
	struct list_head list;
	int trigger_pin;
	int echo_pin;
	int m; //Total samples to be collected
	int delta; //Time period of sample collection
	//code for fifo buffer
} *hcsr04_device_list;


static int hcsr04_open(struct inode *inode, struct file *file)
{
    return 0;
}

static int hcsr04_close(struct inode *inodep, struct file *filp)
{
    return 0;
}

static ssize_t hcsr04_write(struct file *file, const char __user *buf,
		       size_t len, loff_t *ppos)
{
    
    return 0; 
}

static long hcsr04_ioctl(struct file * file, unsigned int ioctlnum, unsigned long arg)
{   

	return 0;
}

static const struct file_operations hcsr04_fops = {
    .owner			= THIS_MODULE,
    .write			= hcsr04_write,
    .open			= hcsr04_open,
    .release		= hcsr04_close,
    .unlocked_ioctl = hcsr04_ioctl
};

static int __init hcsr04_init(void)
{
	int index;
	int error;
	struct hcsr04_device *misc_hcsr04_device;

	INIT_LIST_HEAD(&hcsr04_device_list->list);

	for(index=0; index < devices;index++)
	{
		misc_hcsr04_device = (struct hcsr04_device *)kmalloc(sizeof(struct hcsr04_device), GFP_KERNEL);
		misc_hcsr04_device->misc.minor = MISC_DYNAMIC_MINOR;
		misc_hcsr04_device->misc.name = "HCSR_"+index;
		misc_hcsr04_device->misc.fops = &hcsr04_fops;

	    error = misc_register(&(misc_hcsr04_device->misc));
	    if (error) 
	    {
	        printk("Unable to register HCSR_%d device\n",index);
	        return error;
	    }
	    list_add(&(misc_hcsr04_device->list), &(hcsr04_device_list->list));

	}

    printk("HCSR driver registered with %d devices created.",devices);
    return 0;
}

static void __exit hcsr04_exit(void)
{
	int error;
	struct hcsr04_device *misc_hcsr04_device;
	struct list_head *pos, *q;
	
	list_for_each_safe(pos, q, &hcsr04_device_list->list)
	{
		misc_hcsr04_device = list_entry(pos, struct hcsr04_device, list);
		error = misc_deregister(&misc_hcsr04_device->misc);
	    if (error) {
	        printk("Unable to deregister HCSR device\n");
	    }
		list_del(pos);
		//free(misc_hcsr04_device);
	}
	    
    printk("HCSR driver deregistered and %d devices deleted.",devices);
}

module_init(hcsr04_init)
module_exit(hcsr04_exit)

MODULE_DESCRIPTION("HCSR Driver");
MODULE_AUTHOR("Ravi Bhushan <ravibhushan0487@gmail.com>");
MODULE_LICENSE("GPL");

